问题

 什么是CPU上下文切换？
        现在linux是大多基于抢占式，CPU给每个任务一定的服务时间，当时间片轮转的时候，需要把当前状态保存下来，同时加载下一个任务，这个过程叫做上下文切换。时间片轮转的方式，使得多个任务利用一个CPU执行成为可能，但是保存现场和加载现场，也带来了性能消耗。  那线程上下文切换的次数和时间以及性能消耗如何看呢？      

如何获得上下文切换的次数？
         vmstat直接运行即可，在最后几列，有CPU的context switch次数。 这个是系统层面的，加入想看特定进程的情况，可以使用pidstat。     

PID: 进程pid
%usr: 进程在用户态运行所占cpu时间比率
%system: 进程在内核态运行所占cpu时间比率
%CPU: 进程运行所占cpu时间比率
CPU: 指示进程在哪个核运行
Command: 拉起进程对应的命令
备注:执行pidstat默认输出信息为系统启动后到执行时间点的统计信息，因而即使当前某进程的cpu占用率很高，输出中的值有可能仍为0。
?    ?    
 ??上下文切换的性能消耗在哪里呢？
    ?    ?context switch过高，会导致CPU像个搬运工，频繁在寄存器和运行队列直接奔波  ，更多的时间花在了线程切换，而不是真正工作的线程上。直接的消耗包括CPU寄存器需要保存和加载，系统调度器的代码需要执行。间接消耗在于多核cache之间的共享数据。 
    ?
    ?    ?引起上下文切换的原因有哪些？
    ?    ?对于抢占式操作系统而言， 大体有几种：
    ?    ?1、当前任务的时间片用完之后，系统CPU正常调度下一个任务；
    ?    ?2、当前任务碰到IO阻塞，调度线程将挂起此任务，继续下一个任务；
    ?    ?3、多个任务抢占锁资源，当前任务没有抢到，被调度器挂起，继续下一个任务；
    ?    ?4、用户代码挂起当前任务，让出CPU时间；
    ?    ?5、硬件中断；


反应器模式和观察者模式的区别

将事件多路分用 
将事件分派到各自相应的事件处理程序 

分布式系统中的服务器应用程序必须处理多个向它们发送服务请求的客户机。然而，在调用特定的服务之前，服务器应用程序必须将每个传入请求多路分用并分派到各自相应的服务提供者。反应器模式正好适用于这一功能。它允许事件驱动应用程序将服务请求多路分用并进行分派，然后，这些服务请求被并发地从一个或多个客户机传送到应用程序。 

反应器模式（Reactor pattern）与观察者模式（Observer pattern）在这个方面极为相似：当一个主体发生改变时，所有依属体都得到通知。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 

为什么我们需要mq？
http://book.51cto.com/art/201502/466288.htm

io读取文件，和nio读取文件 区别？
io 读取是通过流读取，一个字符一个字符的读，效率比较低,
nio 对文件读取改进，通过块读取，读出来的是一个块，放到缓冲区（块操作，fileChannel）
mappedByteBuffer内存映射，操作大文件中的一部分
nio 可见对大文件块读取是最好的;如果要直接操作文件的很大的一部分的内容，则比较适合MappedByteBuffer ;如读取很小的内容，比如8B的内容，inputStream可能是最好的。

MappedByteBuffer以及ByteBufer的底层原理??

java io read() write() 为什么会阻塞??
read() 读到结束 返回为-1  在输入数据可用、检测到流末尾或者抛出异常前一直阻塞
readLine() 读取一个文本行。通过下列字符之一即可认为某行已终止：换行 ('\n')、回车 ('\r') 或回车后直接跟着换行

Volatile 变量 使用？
http://www.ibm.com/developerworks/cn/java/j-jtp06197.html


nio的实现原理是什么？
http://www.cnblogs.com/kzfy/p/5063467.html
  Buffer线性，有序的集合


异步io 和 同步io，阻塞和非阻塞 分别是什么情况？
http://www.cnblogs.com/happyhorseji/archive/2011/08/21/2148764.html 
Java里阻塞线程的三种实现方法
https://my.oschina.net/flashsword/blog/114527

mysql 集群
http://shift-alt-ctrl.iteye.com/blog/2266908

虚拟机上网 三种模式
http://blog.csdn.net/xh16319/article/details/17272113